# -*- Makefile -*-
# Makefile for GeekOS kernel, userspace, and tools
# Copyright (c) 2004,2005 David H. Hovemeyer <daveho@cs.umd.edu>
# $Revision: 1.47 $

# This is free software.  You are permitted to use,
# redistribute, and modify it as specified in the file "COPYING".

# Required software to build GeekOS:
# - GNU Make (http://www.gnu.org/software/make)
# - gcc 2.95.2 generating code for target (i386/ELF) and host platforms
# - nasm (http://nasm.sourceforge.net)
# - Perl5, AWK (any version), egrep
#
# Cygwin (http://cygwin.com) may be used to build GeekOS.
# Make sure that gcc, binutils, nasm, and perl are installed.

# NOTES:
# - This makefile has been written carefully to work correctly
#   with the -j (parallel make) option.  I regularly use "make -j 2"
#   to speed the build process on 2 processor systems.

PROJECT_ROOT := ..
VPATH := $(PROJECT_ROOT)/src

# Figure out if we're compiling with cygwin, http://cygwin.com
SYSTEM_NAME := $(shell uname -s)
ifeq ($(findstring CYGWIN,$(SYSTEM_NAME)),CYGWIN)
SYM_PFX            := _
EXTRA_C_OPTS       := -DNEED_UNDERSCORE -DGNU_WIN32
EXTRA_NASM_OPTS    := -DNEED_UNDERSCORE -g
NON_ELF_SYSTEM     := yes
EXTRA_CC_USER_OPTS := -Dmain=geekos_main -fwritable-strings 
endif

#in new versions of qemu for linux can specify port...
RANDOM_PORT := $(shell $(PROJECT_ROOT)/scripts/random_port)

NET_MAC_1 ?= 52:54:00:12:34:58
NET_MAC_2 ?= 52:54:00:12:34:56
QEMU_NETOPTS=-net nic,model=ne2k_isa,vlan=0,macaddr=$(NET_MAC_1) -net socket,vlan=0,connect=localhost:8190 


# ----------------------------------------------------------------------
# Configuration -
#   Various options specifying how GeekOS should be built,
#   what source files to build, which user programs to build,
#   etc.  This is generally the only section of the makefile
#   that will need to be modified.
# ----------------------------------------------------------------------

# List of targets to build by default.
# These targets encompass everything needed to boot
# and run GeekOS.
ALL_TARGETS := diskc.img diskd.img gfs-1024x2048.img


# Kernel source file containing implementation of user address space support
USER_IMP_C := userseg.c
# Kernel source files
KERNEL_C_SRCS := idt.c int.c trap.c irq.c io.c \
	keyboard.c screen.c timer.c \
	mem.c crc32.c \
	gdt.c tss.c smp.c segment.c \
	malloc.c \
	synch.c kthread.c \
	user.c $(USER_IMP_C) argblock.c syscall.c dma.c floppy.c \
	elf.c blockdev.c ide.c \
	vfs.c pfat.c bitset.c bufcache.c \
	$(notdir $(wildcard $(VPATH)/geekos/signal.c)) \
	$(notdir $(wildcard $(VPATH)/geekos/paging.c)) \
	$(notdir $(wildcard $(VPATH)/geekos/sem.c)) \
	$(notdir $(wildcard $(VPATH)/geekos/gosfs.c)) \
	$(notdir $(wildcard $(VPATH)/geekos/cfs.c)) \
	$(notdir $(wildcard $(VPATH)/geekos/percpu.c)) \
	$(addprefix net/, $(notdir $(wildcard $(VPATH)/geekos/net/*.c))) \
	$(addprefix sound/, $(notdir $(wildcard $(VPATH)/geekos/sound/*.c))) \
	$(notdir $(wildcard $(VPATH)/geekos/serial.c)) \
	alarm.c pipe.c \
	main.c 
# signal above is present in pa2 on

# can only fit one of gfs2/gfs3 into memory
ifeq ($(BUILD_GFS2), true)
    KERNEL_C_SRCS += $(notdir $(wildcard $(VPATH)/geekos/gfs2.c))
else
    KERNEL_C_SRCS += $(notdir $(wildcard $(VPATH)/geekos/gfs3.c)) 
endif

# Kernel object files built from C source files
KERNEL_C_OBJS := $(KERNEL_C_SRCS:%.c=geekos/%.o)
# KERNEL_C_OBJS := $(patsubst %.c, geekos/%.o, $(KERNEL_C_SRCS))

# Kernel assembly files
KERNEL_ASM_SRCS := lowlevel.asm lspawn.asm

KERNEL_INCLUDES := $(wildcard $(PROJECT_ROOT)/include/geekos/*.h) $(wildcard $(PROJECT_ROOT)/include/geekos/net/*.h)
ALL_INCLUDES := $(KERNEL_INCLUDES) $(wildcard $(PROJECT_ROOT)/include/libc/*.h)

# Kernel object files build from assembler source files
KERNEL_ASM_OBJS := \
  $(KERNEL_ASM_SRCS:%.asm=geekos/%.o)


# All kernel object files
KERNEL_OBJS := $(KERNEL_ASM_OBJS) $(KERNEL_C_OBJS) 

# Common library source files.
# This library is linked into both the kernel and user programs.
# It provides string functions and generic printf()-style
# formatted output.
COMMON_C_SRCS := fmtout.c string.c memmove.c bget.c

# Common library object files.
COMMON_C_OBJS := $(COMMON_C_SRCS:%.c=common/%.o)
COMMON_KERNEL_C_OBJS := $(COMMON_C_SRCS:%.c=geekos/%.o)

# User libc source files.
LIBC_C_SRCS := $(notdir $(wildcard $(VPATH)/libc/*.c))
# signal when present (PA2 on)

# User libc object files.
LIBC_C_OBJS := $(LIBC_C_SRCS:%.c=libc/%.o) libc/lowlevel.o

# Generated libc source files
GENERATED_LIBC_SRCS := libc/errno.c


# User program source files.
#USER_C_SRCS := \
#	null.c long.c \
#	shell.c b.c c.c
USER_C_SRCS := $(notdir $(wildcard $(VPATH)/user/*.c)) 


# User executables
USER_PROGS := $(USER_C_SRCS:%.c=user/%.exe)

# Base address of kernel
KERNEL_BASE_ADDR := 0x00010000

# Kernel entry point function
KERNEL_ENTRY = $(SYM_PFX)Main

# Kernel entry point for secondary CPUs
KERNEL_ENTRY_2ND = $(SYM_PFX)Secondary_Start

# Base address of user programs
USER_BASE_ADDR := 0x1000

# User program (libc) entry point function
USER_ENTRY = $(SYM_PFX)_Entry


# ----------------------------------------------------------------------
# Tools -
#   This section defines programs that are used to build GeekOS.
# ----------------------------------------------------------------------

# TARGET_CC_PREFIX should be set by the arch-specific makefile 
# if needed for cross-compilation.
#  set it here, and the submit server will not like you.

# Target C compiler.  gcc 2.95.2 or later should work.
# don't override if the including thing has set this one.
# ?= syntax allows TARGET_CC to be set in the arch-specific 
# makefile.
TARGET_CC ?= $(TARGET_CC_PREFIX)gcc

# Host C compiler.  This is used to compile programs to execute on
# the host platform, not the target (x86) platform.  On x86/ELF
# systems, such as Linux and FreeBSD, it can generally be the same
# as the target C compiler.
HOST_CC := gcc

# Target assembler
TARGET_AS := $(TARGET_CC_PREFIX)as

# Target linker.  GNU ld is probably to only one that will work.
TARGET_LD := $(TARGET_CC_PREFIX)ld

# Target archiver
TARGET_AR := $(TARGET_CC_PREFIX)ar

# Target ranlib
TARGET_RANLIB := $(TARGET_CC_PREFIX)ranlib

# Target nm
TARGET_NM := $(TARGET_CC_PREFIX)nm

# Target objcopy
TARGET_OBJCOPY := $(TARGET_CC_PREFIX)objcopy

# Target strip (smaller executables, but harder to extract symbols 
# TARGET_STRIP := $(TARGET_CC_PREFIX)strip
TARGET_STRIP := echo

# Nasm (http://nasm.sourceforge.net)
NASM := nasm

# Tool to build PFAT filesystem images.
BUILDFAT := tools/builtFat.exe

# Perl5 or later
PERL := perl

# Pad a file so its size is a multiple of some unit (i.e., sector size)
PAD := $(PERL) $(PROJECT_ROOT)/scripts/pad

# Create a file filled with zeroes.
ZEROFILE := $(PERL) $(PROJECT_ROOT)/scripts/zerofile

# Calculate size of file in sectors
NUMSECS := $(PERL) $(PROJECT_ROOT)/scripts/numsecs


# Generate C file containing table of error strings from <geekos/errno.h>
GENERRS := $(PERL) $(PROJECT_ROOT)/scripts/generrs

# ----------------------------------------------------------------------
# Definitions -
#   Options passed to the tools.
# ----------------------------------------------------------------------

# Flags used for all C source files
# GENERAL_OPTS := -O -Wall $(EXTRA_C_OPTS) 
GENERAL_OPTS := -Werror -Wall $(EXTRA_C_OPTS)
CC_GENERAL_OPTS ?= $(GENERAL_OPTS) -W -Wwrite-strings -fno-stack-protector -Wno-unused -Wno-unused-parameter -std=gnu99 -fgnu89-inline

# Flags used for kernel C source files
CC_KERNEL_OPTS := -g -DGEEKOS -I$(PROJECT_ROOT)/include -DUSE_VM

# Flags user for kernel assembly files
NASM_KERNEL_OPTS := -I$(PROJECT_ROOT)/src/geekos/ -f elf $(EXTRA_NASM_OPTS)

# Flags used for common library and libc source files
CC_USER_OPTS := -g -DGEEKOS_LIBC -I$(PROJECT_ROOT)/include \
	-I$(PROJECT_ROOT)/include/libc \
	$(EXTRA_CC_USER_OPTS) 

# Flags passed to objcopy program (strip unnecessary sections from kernel.exe)
OBJCOPY_FLAGS := -R .dynamic -R .note -R .comment

# ----------------------------------------------------------------------
# Rules -
#   Describes how to compile the source files.
# ----------------------------------------------------------------------

# Compilation of kernel C source files

TARGET_CC_ARCH=$(shell $(TARGET_CC) -dumpmachine)

# I'm not getting this quite right, but I think the warning is important. -ns
.PHONY: .crosscompilersanity
.crosscompilersanity:
	@echo $(TARGET_CC_ARCH) | egrep '(elf|i386-redhat-linux|i486-linux-gnu)' > /dev/null || echo "WARNING: $(TARGET_CC) builds for " $(TARGET_CC_ARCH)
	@$(NASM) -help > /dev/null || echo "WARNING: nasm missing.  Perhaps sudo apt-get install nasm"
	@mkdir -p geekos user tools libc common geekos/net geekos/sound

geekos/%.o : geekos/%.c $(KERNEL_INCLUDES)
	$(TARGET_CC) -c $(CC_GENERAL_OPTS) $(CC_KERNEL_OPTS) $< -o geekos/$*.o
geekos/%.o : common/%.c $(ALL_INCLUDES)
	$(TARGET_CC) -c $(CC_GENERAL_OPTS) $(CC_KERNEL_OPTS) -I$(PROJECT_ROOT)/include/libc $< -o geekos/$*.o


# Compilation of kernel assembly source files
geekos/%.o : geekos/%.asm
	$(NASM) $(NASM_KERNEL_OPTS) $< -o geekos/$*.o

geekos/%.o : geekos/%.S
	$(TARGET_CC) -c $(CC_GENERAL_OPTS) $(CC_KERNEL_OPTS) $< -o geekos/$*.o

# Compilation of common library C source files
common/%.o : common/%.c $(ALL_INCLUDES)
	$(TARGET_CC) -c $(CC_GENERAL_OPTS) $(CC_USER_OPTS) $< -o common/$*.o

# Compilation of libc source files
libc/%.o : libc/%.c $(ALL_INCLUDES)
	$(TARGET_CC) -c $(CC_GENERAL_OPTS) $(CC_USER_OPTS) $< -o libc/$*.o
libc/%.o : libc/%.s
	$(TARGET_AS) $(AS_GENERAL_OPTS) $< -o $@

# Compilation of user programs
# Strip since gdb won't do anything useful anyway and it reduces
# file size (and thus time to load the executable)
user/%.exe : user/%.c libc/libc.a libc/entry.o $(ALL_INCLUDES)
	$(TARGET_CC) -c $(CC_GENERAL_OPTS) $(CC_USER_OPTS) $< -o user/$*.o
	$(TARGET_LD) $(LD_GENERAL_OPTS) -o $@ -Ttext $(USER_BASE_ADDR) -e $(USER_ENTRY) libc/entry.o user/$*.o libc/libc.a
ifeq ($(NON_ELF_SYSTEM),yes)
	$(TARGET_OBJCOPY) -O elf32-i386 $@ $@
endif
	@$(TARGET_STRIP) $@

# ----------------------------------------------------------------------
# Targets -
#   Specifies files to be built
# ----------------------------------------------------------------------

# Default target - see definition of ALL_TARGETS in Configuration section
all: .crosscompilersanity $(ALL_TARGETS)

# hard drive boot sector
geekos/hdbootsect: $(PROJECT_ROOT)/src/geekos/bootsect.asm $(PROJECT_ROOT)/src/geekos/util.asm
	$(NASM) -DDRIVE_NUMBER=0x80                     \
	-I$(PROJECT_ROOT)/src/geekos/ \
	-f bin -o geekos/hdbootsect $(PROJECT_ROOT)/src/geekos/bootsect.asm

# First hard drive image (15 MB).
# This contains a PFAT filesystem with the user programs on it.
diskc.img : $(USER_PROGS) $(BUILDFAT) geekos/hdbootsect geekos/setup.bin geekos/kernel.bin
	$(ZEROFILE) $@ 40720
	$(ZEROFILE) pagefile.bin 10240
	$(ZEROFILE) mapfile.bin 10240
	$(BUILDFAT) -b geekos/hdbootsect $@ geekos/setup.bin geekos/kernel.bin mapfile.bin pagefile.bin $(wildcard user/*.txt) $(wildcard ../sound/*.wav) $(wildcard user/*.ini) $(USER_PROGS) geekos/hdbootsect -d dirTest -d dirTest/sub1 || ( rm $@ ; exit 1 )

# Second hard drive image (10 MB).
# This will be used for the GeekOS filesystem (GOSFS) image.
diskd.img :
	$(ZEROFILE) $@ 20480

disk3.img : $(USER_PROGS) tools/gfs3f geekos/hdbootsect geekos/setup.bin geekos/kernel.bin
	rm -f $@
	$(ZEROFILE) pagefile.bin 10240
	tools/gfs3f $@ geekos/hdbootsect 30720 geekos/setup.bin geekos/kernel.bin pagefile.bin $(wildcard user/*.txt) $(wildcard ../sound/*.wav) $(USER_PROGS) -d dirTest -d dirTest/sub1 || ( rm $@ ; exit 1 )

disk3d.img : $(USER_PROGS) tools/gfs3f 
	rm -f $@
	tools/gfs3f $@ geekos/hdbootsect 30720 || ( rm $@ ; exit 1 )

disk3d-small.img : $(USER_PROGS) tools/gfs3f 
	rm -f $@
	tools/gfs3f $@ geekos/hdbootsect 512 || ( rm $@ ; exit 1 )

gfs2-1024x256.img : $(USER_PROGS) tools/gfs2f
	rm -f $@
	tools/gfs2f $@ 1024 256 || ( rm $@ ; exit 1 )

# Tool to build PFAT filesystem images
$(BUILDFAT) : $(PROJECT_ROOT)/src/tools/buildFat.c $(PROJECT_ROOT)/include/geekos/pfat.h
	$(HOST_CC) -g $(CC_GENERAL_OPTS) -I$(PROJECT_ROOT)/include $(PROJECT_ROOT)/src/tools/buildFat.c -o $@

# Floppy boot sector (first stage boot loader).
geekos/fd_boot.bin : geekos/setup.bin geekos/kernel.bin $(PROJECT_ROOT)/src/geekos/fd_boot.asm
	$(NASM) -f bin \
		-I$(PROJECT_ROOT)/src/geekos/ \
		-DNUM_SETUP_SECTORS=`$(NUMSECS) geekos/setup.bin` \
		-DNUM_KERN_SECTORS=`$(NUMSECS) geekos/kernel.bin` \
		$(PROJECT_ROOT)/src/geekos/fd_boot.asm \
		-o $@

# Setup program (second stage boot loader).
geekos/setup.bin : geekos/kernel.exe $(PROJECT_ROOT)/src/geekos/setup.asm
	$(NASM) -f bin \
		-I$(PROJECT_ROOT)/src/geekos/ \
		-DENTRY_POINT=0x`egrep 'Main' geekos/kernel.syms |awk '{print $$1}'` \
		-DSECONDARY_ENTRY_POINT=0x`egrep 'Secondary_Start' geekos/kernel.syms |awk '{print $$1}'` \
		-DSECONDARY_STACK=0x`egrep 'Secondary_Stack' geekos/kernel.syms |awk '{print $$1}'` \
		$(PROJECT_ROOT)/src/geekos/setup.asm \
		-o $@
	$(PAD) $@ 512

# Loadable (flat) kernel image.
geekos/kernel.bin : geekos/kernel.exe
	$(TARGET_OBJCOPY) $(OBJCOPY_FLAGS) -S -O binary geekos/kernel.exe geekos/kernel.bin
	$(PAD) $@ 512

# The kernel executable and symbol map.
geekos/kernel.exe : $(KERNEL_OBJS) $(COMMON_KERNEL_C_OBJS) Makefile.common
	$(TARGET_LD) $(LD_GENERAL_OPTS) -o geekos/kernel.exe -Ttext $(KERNEL_BASE_ADDR) -e $(KERNEL_ENTRY) \
		$(KERNEL_OBJS) $(COMMON_KERNEL_C_OBJS)
	$(TARGET_NM) geekos/kernel.exe > geekos/kernel.syms

# C library for user mode programs
libc/libc.a : $(LIBC_C_OBJS) libc/errno.o $(COMMON_C_OBJS)
	$(TARGET_AR) ruv $@ $(LIBC_C_OBJS) libc/errno.o $(COMMON_C_OBJS)
	$(TARGET_RANLIB) $@

# Source file containing the table of error strings for each error code.
# This is derived automatically from the comments in <geekos/errno.h>.
libc/errno.c : $(PROJECT_ROOT)/include/geekos/errno.h $(PROJECT_ROOT)/scripts/generrs
	$(GENERRS) $(PROJECT_ROOT)/include/geekos/errno.h > $@

# Clean build directories of generated files
clean :
	for d in geekos/net geekos/sound geekos common libc user tools; do \
		(cd $$d && rm -f *.bin *.exe *.o *.s *.a); \
	done
	rm -f libc/errno.c geekos/kernel.syms geekos/hdbootsect
	rm -f *.img qemu out.txt core
	rm -f tools/gfs2f pagefile.bin
	rm -rf tools/*.dSYM # mac
	./cleanSymLinks.py

%.vmdk: %.img
	qemu-img convert -O vmdk $< $@

# Build header file dependencies, so source files are recompiled when
# header files they depend on are modified.
depend : $(GENERATED_LIBC_SRCS)
	echo $(TARGET_CC)
	$(TARGET_CC) -M $(CC_GENERAL_OPTS) $(CC_KERNEL_OPTS) \
		$(KERNEL_C_SRCS:%.c=$(PROJECT_ROOT)/src/geekos/%.c) \
		| $(PERL) -n -e 's,^(\S),geekos/$$1,;print' \
		> depend.mak
	$(TARGET_CC) -M $(CC_GENERAL_OPTS) $(CC_USER_OPTS) \
		$(LIBC_C_SRCS:%.c=$(PROJECT_ROOT)/src/libc/%.c) libc/errno.c \
		| $(PERL) -n -e 's,^(\S),libc/$$1,;print' \
		>> depend.mak
	$(TARGET_CC) -M $(CC_GENERAL_OPTS) $(CC_USER_OPTS) \
		$(COMMON_C_SRCS:%.c=$(PROJECT_ROOT)/src/common/%.c) \
		| $(PERL) -n -e 's,^(\S),common/$$1,;print' \
		>> depend.mak

# By default, there are no header file dependencies.
depend.mak :
	touch $@

# submission is not generally used, since the make submit rule is functional
submission.zip:
	make clean
	cd .. && zip -r build/submission.zip src/*/* include/*/* build/Makefile* scripts

../submit.jar:
	cd .. && curl -O http://www.cs.umd.edu/class/fall2010/cmsc330/p4/submit.jar

submit: ../submit.jar ../.submit
	make clean
	cd .. && java -jar submit.jar

gfs-examples: gfs-1024x2048.img gfs-512x2048.img 

gfs-%.img: tools/gfs2f
	$< $@ `ruby -e "puts '$@'.split('x')[0].gsub(/\\D*/,'')"` `ruby -e "puts '$@'.split('x')[1].gsub(/\\D*/,'')"` 

tools/gfs2f: $(PROJECT_ROOT)/src/tools/gfs2f.c $(PROJECT_ROOT)/include/geekos/gfs2.h $(PROJECT_ROOT)/src/geekos/bitset.c $(PROJECT_ROOT)/src/tools/fake-blockdev.c
	$(HOST_CC) -g $(CC_GENERAL_OPTS) -I$(PROJECT_ROOT)/include  $(PROJECT_ROOT)/src/geekos/bitset.c   $(PROJECT_ROOT)/src/tools/gfs2f.c $(PROJECT_ROOT)/src/tools/fake-blockdev.c -o $@ -lm

GFS3F_CFLAGS:=$(CFLAGS) -I../../include -Wall -O0 -Wshadow -Wwrite-strings -Wuninitialized -g -DGEEKOS -DREDEFINE_KASSERT -DGEEKOS_KASSERT_H -DLock_List="(void)" -DUnlock_List="(void)" -DKASSERT=assert -include assert.h -Wno-unused-function

tools/gfs3f: $(PROJECT_ROOT)/src/tools/gfs3f.c $(PROJECT_ROOT)/include/geekos/gfs3.h $(PROJECT_ROOT)/src/geekos/bufcache.c $(PROJECT_ROOT)/src/geekos/bitset.c $(PROJECT_ROOT)/src/tools/fake-blockdev.c $(PROJECT_ROOT)/src/geekos/gfs3.c
	$(HOST_CC) -g $(GFS3F_CFLAGS) -I$(PROJECT_ROOT)/include  $(PROJECT_ROOT)/src/geekos/gfs3.c $(PROJECT_ROOT)/src/geekos/bufcache.c $(PROJECT_ROOT)/src/geekos/bitset.c   $(PROJECT_ROOT)/src/tools/gfs3f.c $(PROJECT_ROOT)/src/tools/fake-blockdev.c -o $@ -lm

# intentionally not .gdbinit so that the dependency is updated.
.PHONY: gdbinit
gdbinit: 
	echo "target remote localhost:$(RANDOM_PORT)" > .gdbinit
	echo "break Dump_Interrupt_State" >> .gdbinit
	echo "break Hardware_Shutdown" >> .gdbinit
	echo "commands 1" >> .gdbinit
	echo "thread apply all bt" >> .gdbinit
	echo "# auto generated in Makefile.common" >> .gdbinit
